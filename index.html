<!--
 ~ Copyright (c) 2011-2012 by Animatron.
 ~ All rights are reserved.
 ~
 ~ Animatron player is licensed under the MIT License, see LICENSE.
 -->

<!DOCTYPE html>
<html>
<head>
    <title>The Animatron HTML5 Player Demo</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <link rel="stylesheet" href="./main.css" type="text/css"/>
    <script src="../player/vendor/matrix.js" type="text/javascript"></script>
    <script src="../player/anm.player.js" type="text/javascript"></script>
    <script src="../player/anm.collisions.js" type="text/javascript"></script>
    <script src="../player/anm.builder.js" type="text/javascript"></script>
    <script src="../player/animatron_import.js" type="text/javascript"></script>
    <!--<script src="anm.SAT.js" type="text/javascript"></script>-->
    <script type="text/javascript">
        function start() {
            anm.M.collisions.pathDriven = true;
            var b = Builder._$, C = anm.C;

            var fhsv = Builder.fhsv;

            var WIDTH = 600;
            var HEIGHT = 450;
            var RADIUS = 10;

            var countFrames = function () {
                if (this.currentFrame === undefined) this.currentFrame = 0;
                else this.currentFrame += 1;
            };

            var doIfThis = function (cond, l) {
                return function (t, d) {
                    if (cond.call(this)) {
                        return l.call(this, t, d);
                    }
                }
            };

            var doIf = function (cond, l) {
                return function (t, d) {
                    if (cond()) {
                        return l.call(this, t, d);
                    }
                }
            };

            var currentFrameEq = function (i) {
                return function () {
                    return this.currentFrame === i
                };
            };

            var currentFrameGt = function (i) {
                return function () {
                    return this.currentFrame > i
                };
            };

            var currentFrameLt = function (i) {
                return function () {
                    return this.currentFrame < i
                };
            };

            var onFrame = function (i, l) {
                return doIfThis(currentFrameEq(i), l);
            };

            var afterFrame = function (i, l) {
                return doIfThis(currentFrameGt(i), l);
            };

            var init = function (t) {
                this.dead = false;
                this.name = Math.random();
                this.x = Math.random() * (WIDTH - RADIUS * 5) + 2.5 * RADIUS;
                this.y = Math.random() * (HEIGHT - RADIUS * 5) + 2.5 * RADIUS;
                this.speed = [Math.random() > .3 ? 1 : -1, Math.random() > .3 ? 1 : -1];
            };

            var logFrame = function () {
                console.log("Current frame:", this.currentFrame);
            };

            var move = function (t) {
                if (this._.speed != undefined) {
                    this.x = this._.x + this._.speed[0];
                    this.y = this._.y + this._.speed[1];
                }
            };
            var updateSpeed = function (t) {
                if (this.speed != undefined && this._.speed != undefined) {
                    if (this.x > WIDTH) this.speed[0] = -this._.speed[0];
                    if (this.x < 0) this.speed[0] = -this._.speed[0];
                    if (this.y > HEIGHT) this.speed[1] = -this._.speed[1];
                    if (this.y < 0) this.speed[1] = -this._.speed[1];
                }
            };

            var clicks = 3;
            var scores = 0;
            var chainscores = 0,
                prevscores = 0;

            var scoreChain = function() {
                var p = chainscores;
                chainscores = chainscores + prevscores;
                prevscores = p;
            };

            var startChain = function() {
                scores += chainscores;
                prevscores = 1;
                chainscores = 1;
            };

            var handler = function (evt, time) {
                    if (clicks > 0 && this.$.contains(evt.pos)) {
                        this.dead = true;
                        startChain();
                    }
                };
            var explodeDead = function(time) {
                if (this._.dead) {
                    var exp = b(explosion);
                    exp.v.state.x = this.x;
                    exp.v.state.y = this.y;
                    exp.band([time, Number.MAX_VALUE]);
                    this.$.parent.add(exp);
                    this.$.parent.remove(this.$);
                }
            };

            var circle_thingy = b("circle thingy")
                    .circle([0, 0], RADIUS)
                    .nostroke()
                    .modify(explodeDead)
                    .modify(countFrames)
                    .modify(onFrame(1, init))
                    .modify(afterFrame(1, move))
                    .modify(afterFrame(1, updateSpeed))
                    .on(C.X_MCLICK, handler);

            var explosion = b("explosion").circle([0, 0], RADIUS)
                    .fill(fhsv(.5, 1, 1, 1))
                    .stroke(fhsv(.5, .5, .5, 1))
                    .xscale([0, 1], [1, 6], C.E_BIN)
                    .alpha([0, 1], [1, 0], C.E_BIN)
                    .modify(function(t){
                        //TODO: remove workaround and use proper t > 1
                        if (t > .9) {
                            this.$.parent.remove(this.$);
                        }
                    });

            var detectCollisions = function(t) {
                var circles = [];
                var explosions = [];
                var i, j;
                for (i = 0; i < this.$.children.length; i ++) {
                    var el = this.$.children[i];
                    el.name === "explosion" ? explosions.push(el) : circles.push(el);
                }
                for (i = 0; i < explosions.length; i ++) {
                    for (j = 0; j < circles.length; j ++) {
                        if (explosions[i].intersects(circles[j])) {
                            circles[j].state.dead = true;
                            scoreChain();
                        }
                    }
                }
            };

            var level1 = b('level')
                .modify(countFrames)
                .modify(detectCollisions);
            var counter = 22;
            while (counter -- > 0) {
                level1.add(b(circle_thingy).fill(fhsv(Math.random(), 1, 1, 1)));
            };
            var gameScreen = b('scene').band([0, Number.MAX_VALUE]);
            var clicksHUD = b("clicksHUD").band([0, Number.MAX_VALUE]).text([10,10], "Clicks: 3", 12, "Arial");

            clicksHUD.on(C.X_MCLICK, function(){
                clicks = --clicks < 0 ? 0 : clicks;
                this.$.xdata.text.lines = "Clicks: " + clicks;
                });

            var scoreHUD = b("scoreHUD").band([0, Number.MAX_VALUE]).text([WIDTH - 63,10], "Score: 0", 12, "Arial");
            scoreHUD.modify(function(){
                this.$.xdata.text.lines = "Score: " + (scores + chainscores);
            });

            gameScreen.add(level1);
            gameScreen.add(clicksHUD);
            gameScreen.add(scoreHUD);

            var player = createPlayer('gameCanvas', {'mode':C.M_DYNAMIC, 'cnvs':{'width':WIDTH, 'height':HEIGHT}});
            player.debug = false;
            var startGame = function (level) {
                player.load(gameScreen).play();
            };

            startGame(level1);
        }
    </script>
</head>

<body onload="start();">
<h1>Chain Reaction – game built on The Animatron engine</h1>

<canvas id="gameCanvas"></canvas>

<div id="copyright"><span>© 2011-2012 by Animatron.</span></div>

</body>

</html>