<!--
 ~ Copyright (c) 2011-2012 by Animatron.
 ~ All rights are reserved.
 ~
 ~ Animatron player is licensed under the MIT License, see LICENSE.
 -->

<!DOCTYPE html>
<html>
<head>
    <title>The Animatron HTML5 Player Demo</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <link rel="stylesheet" href="./main.css" type="text/css"/>
    <script src="../player/vendor/matrix.js" type="text/javascript"></script>
    <script src="../player/anm.player.js" type="text/javascript"></script>
    <script src="../player/anm.collisions.js" type="text/javascript"></script>
    <script src="../player/anm.builder.js" type="text/javascript"></script>
    <script src="../player/animatron_import.js" type="text/javascript"></script>
    <!--<script src="anm.SAT.js" type="text/javascript"></script>-->
    <script type="text/javascript">
        function start() {
            anm.MODULES['COLLISIONS'].pathCheck = false;
            var b = Builder._$, C = anm.C;

            var fhsv = Builder.fhsv;

            var WIDTH = 400;
            var HEIGHT = 300;
            var RADIUS = 10;

            var countFrames = function () {
                if (this.currentFrame === undefined) this.currentFrame = 0;
                else this.currentFrame += 1;
            };

            var doIfThis = function (cond, l) {
                return function (t, d) {
                    if (cond.call(this)) {
                        return l.call(this, t, d);
                    }
                }
            };

            var doIf = function (cond, l) {
                return function (t, d) {
                    if (cond()) {
                        return l.call(this, t, d);
                    }
                }
            };

            var currentFrameEq = function (i) {
                return function () {
                    return this.currentFrame === i
                };
            };

            var currentFrameGt = function (i) {
                return function () {
                    return this.currentFrame > i
                };
            };

            var currentFrameLt = function (i) {
                return function () {
                    return this.currentFrame < i
                };
            };

            var onFrame = function (i, l) {
                return doIfThis(currentFrameEq(i), l);
            };

            var afterFrame = function (i, l) {
                return doIfThis(currentFrameGt(i), l);
            };

            var init = function (t) {
                this.name = Math.random();
                this.x = Math.random() * (WIDTH - RADIUS * 5) + 2.5 * RADIUS;
                this.y = Math.random() * (HEIGHT - RADIUS * 5) + 2.5 * RADIUS;
                this.speed = [Math.random() > .3 ? 1 : -1, Math.random() > .3 ? 1 : -1];
            };

            var logFrame = function () {
                console.log("Current frame:", this.currentFrame);
            };

            var move = function (t) {
                if (this._.speed != undefined) {
                    this.x = this._.x + this._.speed[0];
                    this.y = this._.y + this._.speed[1];
                }
            };
            var updateSpeed = function (t) {
                if (this.speed != undefined && this._.speed != undefined) {
                    if (this.x > WIDTH) this.speed[0] = -this._.speed[0];
                    if (this.x < 0) this.speed[0] = -this._.speed[0];
                    if (this.y > HEIGHT) this.speed[1] = -this._.speed[1];
                    if (this.y < 0) this.speed[1] = -this._.speed[1];
                }
            };

            var clicks = 3;

            var hasClicks = function () {
                return clicks > 0;
            };

            var handler = function (evt, time) {
                    if (this.$.contains(evt.pos)) {
                        this.dead = true;
                    }
                };
            var explodeDead = function(time) {
                if (this._.dead) {
                    var exp = b(explosion);
                    exp.v.state.x = this.x;
                    exp.v.state.y = this.y;
                    exp.band([time, time+1]);
                    this.$.parent.add(exp);
                    this.$.parent.remove(this.$);
                }
            };

            var circle_thingy = b("circle thingy").band([0, Number.MAX_VALUE]).circle([0, 0], RADIUS)
                    .fill(fhsv(1, 1, 1, 1))
                    .stroke(fhsv(1, .5, .5, 1))
                    .modify(explodeDead)
                    .modify(countFrames)
                    .modify(onFrame(1, init))
                    .modify(afterFrame(1, move))
                    .modify(afterFrame(1, updateSpeed))
                    .on(C.X_MCLICK, handler);

            var explosion = b("explosion").band([0, Number.MAX_VALUE]).circle([0, 0], RADIUS)
                    .fill(fhsv(.5, 1, 1, 1))
                    .stroke(fhsv(.5, .5, .5, 1))
                    .xscale([0, 1], [1, 6], C.E_BIN)
                    .alpha([0, 1], [1, 0], C.E_BIN)
                    .modify(function(t){
                                            //TODO: remove workaround and use proper t > 1
                                            if (t > .9) {
                                                this.$.parent.remove(this.$);
                                            }
                                        });

            var detectCollisions = function(t) {
                var circles = [];
                var explosions = [];
                var i, j;
                for (i = 0; i < this.$.children.length; i ++) {
                    var el = this.$.children[i];
                    el.name === "explosion" ? explosions.push(el) : circles.push(el);
                }
                for (i = 0; i < explosions.length; i ++) {
                    for (j = 0; j < circles.length; j ++) {
                        if (explosions[i].intersects(circles[j])) {
                            circles[j].state.dead = true;
                        }
                    }
                }
            };

            var level1 = b('scene').band([0, Number.MAX_VALUE]);
            level1.modify(countFrames);
            level1.modify(detectCollisions);
            level1.add(b(circle_thingy));
            level1.add(b(circle_thingy));
            level1.add(b(circle_thingy));
            level1.add(b(circle_thingy));
            level1.add(b(circle_thingy));
            level1.add(b(circle_thingy));
            level1.add(b(circle_thingy));
            level1.add(b(circle_thingy));
            level1.add(b(circle_thingy));
            level1.add(b(circle_thingy));
            level1.add(b(circle_thingy));
            level1.add(b(circle_thingy));
            level1.add(b(circle_thingy));
            level1.add(b(circle_thingy));
            level1.add(b(circle_thingy));
            level1.add(b(circle_thingy));
            level1.add(b(circle_thingy));
            level1.add(b(circle_thingy));
            level1.add(b(circle_thingy));
            level1.add(b(circle_thingy));
            level1.add(b(circle_thingy));
            level1.add(b(circle_thingy));

            var player = createPlayer('gameCanvas', {'mode':C.M_DYNAMIC, 'cnvs':{'width':WIDTH, 'height':HEIGHT}});
            player.debug = false;
            var startLevel = function (level) {
                player.load(level).play();
            };

            startLevel(level1);
        }
    </script>
</head>

<body onload="start();">
<h1>Chain Reaction – game built on The Animatron engine</h1>

<canvas id="gameCanvas"></canvas>

<div id="copyright"><span>© 2011-2012 by Animatron.</span></div>

</body>

</html>